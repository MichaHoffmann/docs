---
title: Linting PromQL expressions using semgrep
created_at: 2023-07-23
kind: article
author_name: Michael Hoffmann (https://github.com/MichaHoffmann)
---

### Motivation

Writing good alerting rules is surprisingly hard in my experience. Consider the following alerting rule:

```
expr: -|
    sum(rate(http_requests_total{route="/health", status~="5.."}[5m])) 
    /
    sum(rate(http_requests_total{route="/health"}[5m])) 
    > 0.1
```

which seems innocent, until you notice that you forgot to match the `tenant_id` label to your team and discover
that you didn't get paged for `/health` failures for a while.

Enter [semgrep](https://semgrep.dev/)!

### Semgrep

Semgrep is a static analysis tool that allows to write patterns that resemble the syntax of the language that is
to be analyzed ( and far more, please read their docs for details ). From version `1.33.0` onwards Semgrep will have experimental support for PromQL
have experimental support which means that we can use its pattern matching goodness to catch bad queries!
Remember our first example with the missing `tenant_id` label matcher? We could write the following rule to catch
that automatically:

```yaml
rules:
- id: selectors-should-have-tenant-id
  languages: [yaml]
  severity: ERROR
  patterns:
  - pattern-inside: |
      expr: $PROMQL
  - metavariable-pattern:
      language: promql 
      metavariable: $PROMQL
      patterns:
      - pattern-either: 
        - pattern: $X{...}
        - pattern: $X{...}[$D]
      - pattern-not: $X{..., tenant_id=$VAL, ...}
      - pattern-not: $X{..., tenant_id=$VAL, ...}[$D]
  message: Selector expressions should contain a equality match on the tenant_id label.
```

which finds our offending expression:

```bash
semgrep scan -c rule.yaml alertmanager.yaml


┌─────────────┐
│ Scan Status │
└─────────────┘
  Scanning 1 file tracked by git with 1 Code rule:
  Scanning 1 file.
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 100% 0:00:00                                                                                                      


┌────────────────┐
│ 1 Code Finding │
└────────────────┘

    alertmanager.yaml
       selectors-should-have-tenant-id
          Selector expressions should contain a equality match on the tenant_id label.

            5┆ expr: |
            6┆   sum(rate(http_requests_total{route="/health", status="5.."}[5m]))
            7┆   /
            8┆   sum(rate(http_requests_total{route="/health"}[5m]))
            9┆   > 0.1



┌──────────────┐
│ Scan Summary │
└──────────────┘

Ran 1 rule on 1 file: 1 finding.
```

Running this rule now in CI we can rest assured that this class of problem is solved. Lets go over
the config really quick. Since PromQL is not the format of a whole file we need to tell semgrep to
search for it in the `expr` field of a yaml document:

```
  patterns:
  - pattern-inside: |
      expr: $PROMQL
```

This might be a bit cumbersome but also pretty powerful since it abstracts away where to find your
expression. Semgrep also understands `json` so all of this is applicable to expressions buried
in json, or any other supported language for that matter. This pattern will bind the query to the
`metavariable` `$PROMQL`. We can then recursively pattern match against `$PROMQL` in the next step:

```
  - metavariable-pattern:
      language: promql 
      metavariable: $PROMQL
      patterns:
      - pattern-either: 
        - pattern: $X{...}
        - pattern: $X{...}[$D]
      - pattern-not: $X{..., tenant_id=$VAL, ...}
      - pattern-not: $X{..., tenant_id=$VAL, ...}[$D]
```

in this case flagging all vector and matrix selectors that do not have the `tenant_id` label. It
might be a bit cumbersome to distinguish between vector and matrix selectors here but thats a
caveat of the first version and will change in future releases. You could even refine the rule
to make sure that `tenant_id` matches your team by matching the `$VAL` `metavariable` further.

### Caveats

A small enumeration of current first-version shortcomings from the top of my head:

* Currently its not possible to write a rule like `... + ...` to match any additions since `...` is not supported yet in binary operators
* `$X` will not match `http_requests_total{foo="bar"}` but `$X{...}` will, adding the ellipsis is alway recommended for now
* `$X{foo="bar"}` will not match `rate(http_requests_total{foo="bar"}[5m])` because currently a vector selector does not match a matrix selector
* `$F(...)` will match `sum(rate(http_requests_total[5m]))` but not `sum by (route) (rate(http_requests_total[5m]))`, that needs `$F by (...) (...)`

I do plan to address all of those though.

